import { IpAddress } from './index';

describe('IpParseUtils', () => {
  it('recognizes invalid IP addresses', () => {
    let testData = [
      '0010.0.0.0',
      '10.0.0',
      '10.0',
      '10',
      '256.1.1.1',
      '999.999.999.999',
      'a.1.1.1',
      ':::',
      '0:0:0:0:0:0:0:',
      ':0:0:0:0:0:0:0',
      '1200::AB00:1234::2552:7777:1313',
      '1200:0000:AB00:1234:N000:2552:7777:1313',
      '1200:0000:AB00:01234:000:2552:7777:1313',
      '1:2:3:4:5:6:7:8:9:a:b:c:d:e:f',
      '1:2:3:4:5:6:7:8:9:a:b:c:d:e:f::',
      '::1:2:3:4:5:6:7:8:9:a:b:c:d:e:f',
      '1:2:3:4:5:6:7:8:9:a:b:c:d:e:f::1:2:3',
      '1:2:3::1:2:3:4:5:6:7:8:9:a:b:c:d:e:f',
      '::1::2',
      '1::2::',
      '::1:2::3:4',
      '1:2::3:4::',
      '1::2:3::4',
      ':a:b::',
    ];

    for (let line of testData) {
      expect(() => IpAddress.of(line)).toThrowError();
    }
  });

  it('parses valid IP addresses correctly', () => {
    let testData = [
      '10.0.0.0',
      '010.000.001.002',
      '10.000.0.000',
      'f:f00:0:0:f00:0:0:0',
      '0:0:0:0F:F00:0:0:F00',
      '2001:0:0:f:f00:0:0:1',
      '::',
      '1200::AB00:1234:2552:7777:1313',
      '1200:0000:AB00:1234:0000:2552:7777:1313',
      '1:2:3:4:5:6:7:8',
      'a:b:c:d:e:f:1:2',
      '::1:2:3:4:5:6',
      '1:2:3:4:5:6::',
      '::192.168.2.1',
      '::ffff:192.168.3.2',
    ];

    for (let line of testData) {
      expect(IpAddress.of(line)).toBeDefined();
    }
  });
});
